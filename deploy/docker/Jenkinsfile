// @Library('pipeline-library') _  // Use Shared Libraries if available

// import groovy.yaml.YamlSlurper

pipeline {
    agent any
    environment {
        AWS_ACCOUNT_ID = "${ params.Account }"
        AWS_REGION = 'us-east-1'
        IMAGE_TAG = ${git rev-parse --short HEAD}
        IMAGE_NAME = 's3dashboard'
        ROLE_NAME = 'jenkinsAdminXacnt'
    }


    stages {
        stage('Set Environment Variables') {
            steps {
                sh 'echo "Account ID: ${AWS_ACCOUNT_ID}"'
                sh 'echo "Setting Environment Variables"'
                sh 'ls -la deploy/docker'
                script {
                    config = readYaml file: 'deploy/docker/config.yaml'
                    accountConfig = config["aws_accounts"]["${AWS_ACCOUNT_ID}"]
                    env.TF_VAR_aws_account_id = AWS_ACCOUNT_ID
                    env.TF_VAR_aws_security_group = accountConfig.security_group
                    env.TF_VAR_aws_subnet_ids = groovy.json.JsonOutput.toJson(accountConfig.subnet_ids)
                    env.TF_VAR_aws_vpc_id = accountConfig.vpc_id
                    env.TF_BUCKET = accountConfig.tf_bucket
                    env.TF_TABLE = accountConfig.tf_table
                    env.TF_VAR_aws_ssl_certificate_arn = accountConfig.ssl_certificate_arn
                    env.TF_VAR_aws_route53_zone_id = accountConfig.route53_zone_id
                    env.TF_VAR_aws_domain = accountConfig.domain
                    env.TF_VAR_aws_subdomain = "${ params.Subdomain }"
                    env.TF_VAR_aws_ecr_image_tag = IMAGE_TAG
                }
                sh 'echo "Environment Variables Set"'
            }
        }
        stage('Test Yaml Configs') {
            steps {
                script {
                    echo "Security Group: ${env.TF_VAR_aws_security_group}"
                    echo "Subnet IDs: ${env.TF_VAR_aws_subnet_ids}"
                    echo "VPC ID: ${env.TF_VAR_aws_vpc_id}"
                    echo "Terraform Bucket: ${env.TF_BUCKET}"
                    echo "Terraform Table: ${env.TF_TABLE}"
                    echo "SSL Certificate ARN: ${env.TF_VAR_aws_ssl_certificate_arn}"
                    echo "Route53 Zone ID: ${env.TF_VAR_aws_route53_zone_id}"
                    echo "Domain: ${env.TF_VAR_aws_domain}"
                    echo "Subdomain: ${env.TF_VAR_aws_subdomain}"
                }
            }
        }
        stage('Terraform Backend') {
            steps {
                script {
                        terraformInit = {
                            sh """
                                terraform init -reconfigure \
                                    -backend-config="bucket=${env.TF_BUCKET}" \
                                    -backend-config="key=${env.TF_VAR_aws_subdomain}.${env.TF_VAR_aws_domain}/terraform.tfstate" \
                                    -backend-config="region=${AWS_REGION}" \
                                    -backend-config="dynamodb_table=${env.TF_TABLE}"
                            """
                        }
                }
            }
        }
        stage('AssumeRole') {
            steps {
                script {
                    def assumeRoleCmd = """
                        aws sts assume-role --role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/${ROLE_NAME} --role-session-name CrossAccountSession
                    """
                    def assumeRoleOutput = sh(script: assumeRoleCmd, returnStdout: true).trim()
                    def creds = readJSON(text: assumeRoleOutput).Credentials

                    env.AWS_ACCESS_KEY_ID = creds.AccessKeyId
                    env.AWS_SECRET_ACCESS_KEY = creds.SecretAccessKey
                    env.AWS_SESSION_TOKEN = creds.SessionToken
                }
            }
        }
        // stage('Retrieve Last Image for Destroy') {
        //     when {
        //         expression { params.Options == 'Deploy' || params.Options == 'Destroy' }
        //     }
        //     steps {
        //         script {
        //             dir('deploy/docker') {
        //                 terraformInit()
        //                 env.AWS_ECR_IMAGE = sh(script: "terraform output -raw aws_ecr_image || echo ''", returnStdout: true).trim()
        //                 if (!env.AWS_ECR_IMAGE?.trim()) {
        //                     echo "No previous image found, skipping ECR image cleanup."
        //                 } else {
        //                     echo "Retrieved ECR image for cleanup: ${AWS_ECR_IMAGE}"
        //                 }
        //             }
        //         }
        //     }
        // }
        stage('Terraform Destroy Infrastructure') {
            when {
                expression { params.Options == 'Deploy' || params.Options == 'Destroy' }
            }
            steps {
                // go to deploy/docker directory
                dir('deploy/docker') {
                    terraformInit()
                    sh 'terraform destroy -auto-approve || echo "No existing infrastructure to destroy."'
                }
            }
        }
        stage('Terraform Deploy ECR Repository') {
            when {
                expression { params.Options == 'Deploy' || params.Options == 'Update' || params.Options == 'UpdateECR' }
            }
            steps {
                script {
                    dir('deploy/docker') {
                        terraformInit()
                        try {
                            sh 'terraform plan -out=ecr.tfplan -target=aws_ecr_repository.ecr'
                            sh 'terraform apply -auto-approve ecr.tfplan'
                            env.ECR_REPOSITORY_URL = sh(script: 'terraform output -raw ecr_repository_url', returnStdout: true).trim()
                            sh 'echo "ECR Repository URL: ${ECR_REPOSITORY_URL}"'
                        } catch (Exception e) {
                            echo "Terraform apply failed: ${e}"
                            echo "Rolling back changes"
                            sh "terraform destroy -auto-approve"
                            echo "Exiting due to Terraform apply failure"
                        }
                    }
                }
            }
        }
        stage('Build Docker Image') {
            when {
                expression { params.Options == 'Deploy' || params.Options == 'Update'  }
            }
            steps {
                script {
                    sh 'aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
                    sh 'docker build -t ${IMAGE_NAME}:${IMAGE_TAG} .'
                }
            }
        }
        stage('Publish Docker Image') {
            when {
                expression { params.Options == 'Deploy' || params.Options == 'Update'  }
            }
            steps {
                script {
                    sh "docker tag ${IMAGE_NAME}:${IMAGE_TAG} ${ECR_REPOSITORY_URL}:${IMAGE_TAG}"
                    sh "docker push ${ECR_REPOSITORY_URL}:${IMAGE_TAG}"
                }
            }
        }
        stage('Terraform Update ECS Service') {
            when {
                expression { params.Options == 'Deploy' || params.Options == 'Update' || params.Options == 'UpdateECR' }
            }
            steps {
                script {
                    dir('deploy/docker') {
                        terraformInit()
                        sh "terraform plan -out=ecs-update.tfplan -var 'aws_ecr_image=${ECR_REPOSITORY_URL}:${IMAGE_TAG}'"
                        sh "terraform apply -auto-approve ecs-update.tfplan"
                    }
                }
            }
        }
    }
}
